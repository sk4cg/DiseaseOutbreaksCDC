---
title: "DiseaseOutbreaks"
author: "Wasted Potential: Sneha, RyeAnne, Yuqi, Ben"
date: "4/2/2020"
output:
  html_document:
    code_folding: hide
    # number_sections: true
    toc: yes
    toc_depth: 3
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '3'
---

```{r setup, include=FALSE}
# some of common options (and the defaults) are: 
# include=T, eval=T, echo=T, results='hide'/'asis',..., collapse=F, warning=T, message=T, error=T, cache=T, fig.width=6, fig.height=4, fig.dim=c(6,4) #inches, fig.align='left'/'center','right', 
# knitr::opts_chunk$set(warning = F, results = 'markup', message = F)
knitr::opts_chunk$set(warning = F, results = 'hide', message = F)
# knitr::opts_chunk$set(include = F)
# knitr::opts_chunk$set(echo = TRUE)
options(scientific=T, digits = 3) 
# options(scipen=9, digits = 3) 
# ‘scipen’: integer. A penalty to be applied when deciding to print numeric values in fixed or exponential notation.  Positive values bias towards fixed and negative towards scientific notation: fixed notation will be preferred unless it is more than ‘scipen’ digits wider.
# use scipen=999 to prevent scientific notation at all times
```

```{r basic, include=F}
# use this function to conveniently load libraries and work smoothly with knitting
# can add quietly=T option to the require() function
loadPkg = function(pkg, character.only = FALSE) { 
  if (!character.only) { pkg <- as.character(substitute(pkg)) }
  pkg <- ifelse(!character.only, as.character(substitute(pkg)) , pkg)  
  if (!require(pkg,character.only=T, quietly =T)) {  install.packages(substitute(pkg),dep=T); if(!require(pkg,character.only=T)) stop("Package not found") } 
}
loadPkg(knitr)
loadPkg(tidyverse)
loadPkg(ggplot2)
loadPkg(stringr)
loadPkg(maps)
loadPkg(mapdata)
loadPkg(usmap)
loadPkg(tree)
loadPkg(caret) 


# unload/detact package when done using it
unloadPkg = function(pkg, character.only = FALSE) { 
  if(!character.only) { pkg <- as.character(substitute(pkg)) } 
  search_item <- paste("package", pkg,sep = ":") 
  while(search_item %in% search()) { detach(search_item, unload = TRUE, character.only = TRUE) } 
}
```


## Pre-processing

Here, the data is read in as 'outbreaks.'
```{r reading in data, include = T}
outbreaks <- read.csv('outbreaks.csv')

#str(outbreaks)

#summary(outbreaks)
```

# Summary of Data
```{r}
outbreak <- read.csv("outbreaks.csv")
summary(outbreak)
str(outbreak)
```

#### 'NA' Data

After skimming through the data set, I noticed that several predictors contained a large number of missing values. It is important to note that the missing 
values are denoted as '' instead of 'NA.' The largest occurances of missing values were in Serotype/Genotype (15,212 points, or 79.56% of datatset) and 
Ingredient (17,243 points, or 90.18% of dataset). Food contained 8,963 missing values (46.88% of dataset). Species and Status also contained a respectable 
number of missing values (6,619 points, or 34.62% of dataset).
```{r exploring the data, include = T}
year_na <- subset(outbreaks, Year == '') # 0 missing values

month_na <- subset(outbreaks, Month == '') # 0 missing values

location_na <- subset(outbreaks, Location == '') # 2,166 missing values (11.32% of dataset)

food_na <- subset(outbreaks, Food == '') # 8,963 missing values (46.88% of dataset)

ingredient_na <- subset(outbreaks, Ingredient == '') # 17,243 missing values (90.18% of dataset)

species_na <- subset(outbreaks, Species == '') # 6,619 missing values (34.62% of dataset)

serotype.genotype_na <- subset(outbreaks, Serotype.Genotype == '') # 15,212 missing values (79.56% of dataset)

status_na <- subset(outbreaks, Status == '') # 6,619 missing values (34.62% of dataset)

illnesses_na <- subset(outbreaks, Illnesses == '') # 0 missing values

hospitalizations_na <- subset(outbreaks, Hospitalizations == '') # 0 missing values

fatalities_na <- subset(outbreaks, Fatalities == '') # 0 missing values
```

#### Outlier Discovery

After constructing boxplots on the numerical variables (excluding year), outliers were discovered in illnesses, hospitalizations and fatalities.

• Illnesses: with an IQR of 24, there are technically 1,782 outliers. 

• Hospitalizations: with an IQR of 1.5, there are technically 1,325 outliers. 

• Fatalities: with an IQR of 0, there are technically 176 outliers. 

However, these outliers are significant and should not be excluded. Outliers can help explain what species of foodborne illnesses are the 
most destructive, or what predictors are especially harmful (i.e. State, Location). For example, in the case of illnesses the largest 
observation was recorded in a multistate area at a restaurant/private home residence/cateering service and came from salmonella. Perhaps 
the location has something to do with why so many people got sick. Or, salmonella could be an especially dangerous disease. Excluding this 
outlier could produce harmful effects and cloud judgement on what factors predict the causitive agent in foodborne disease outbreaks. 
```{r graphs, include = T}
illnesses_bp <- boxplot(outbreaks$Illnesses, main = "Boxplot of Illnesses", ylab = "Number of Illnesses")

outliers_illnesses <- subset(outbreaks, Illnesses > 43)

hospitalizations_bp <- boxplot(outbreaks$Hospitalizations, main = "Boxplot of Hospitalizations", ylab = "Number of Hospitalizations")

outliers_hospitalizations <- subset(outbreaks, Hospitalizations > 2.5)

fatalities_bp <- boxplot(outbreaks$Fatalities, main = "Boxplot of Fatalities", ylab = "Number of Fatalities")

outliers_fatalities <- subset(outbreaks, Fatalities > 0)
```

# EDA

### Illnesses across the states change in different years. 

```{r}
levels(outbreak$State)[levels(outbreak$State)=="Washington DC"] <- "District of Columbia"

# In 1998
ill1998 <- outbreak %>% filter(Year == 1998) %>%
  group_by(State) %>% 
  summarise(illness = mean(Illnesses, na.rm=T)) %>%
  left_join(x=statepop, by=c("full"="State")) %>%
  select(fips, abbr, full, illness)
plot_usmap(data=ill1998, values="illness", color=1, labels = T) +
  scale_fill_continuous(name="Illnesses",
                        low = "yellow", high = "red",
                        label=scales::comma) + 
  ggtitle(paste0("Illnesses by state in ", 1998)) +
  theme(legend.position = "right",
        plot.title = element_text(hjust = 0.5, size=14))

# In 2004
ill2004 <- outbreak %>% filter(Year == 2004) %>%
  group_by(State) %>% 
  summarise(illness = mean(Illnesses, na.rm=T)) %>%
  left_join(x=statepop, by=c("full"="State")) %>%
  select(fips, abbr, full, illness)
plot_usmap(data=ill2004, values="illness", color=1, labels = T) +
  scale_fill_continuous(name="Illnesses",
                        low = "yellow", high = "red",
                        label=scales::comma) + 
  ggtitle(paste0("Illnesses by state in ", 2004)) +
  theme(legend.position = "right",
        plot.title = element_text(hjust = 0.5, size=14))

# In 2010 
ill2010 <- outbreak %>% filter(Year == 2010) %>%
  group_by(State) %>% 
  summarise(illness = mean(Illnesses, na.rm=T)) %>%
  left_join(x=statepop, by=c("full"="State")) %>%
  select(fips, abbr, full, illness)
plot_usmap(data=ill2010, values="illness", color=1, labels = T) +
  scale_fill_continuous(name="Illnesses",
                        low = "yellow", high = "red",
                        label=scales::comma) + 
  ggtitle(paste0("Illnesses by state in ", 2010)) +
  theme(legend.position = "right",
        plot.title = element_text(hjust = 0.5, size=14))

# In 2015
ill2015 <- outbreak %>% filter(Year == 2015) %>%
  group_by(State) %>% 
  summarise(illness = mean(Illnesses, na.rm=T)) %>%
  left_join(x=statepop, by=c("full"="State")) %>%
  select(fips, abbr, full, illness)
plot_usmap(data=ill2015, values="illness", color=1, labels = T) +
  scale_fill_continuous(name="Illnesses",
                        low = "yellow", high = "red",
                        label=scales::comma) + 
  ggtitle(paste0("Illnesses by state in ", 2015)) +
  theme(legend.position = "right",
        plot.title = element_text(hjust = 0.5, size=14))

```


### The general trend of foodborne illnesses over the years and months

```{r}
# By year
outbreak %>% group_by(Year) %>%
  summarise(Illness = sum(Illnesses, na.rm=T)) %>%
  ggplot(aes(x = Year, y = Illness)) +
  geom_bar(stat = "identity", fill = "cadetblue3") +
  geom_text(aes(label = Illness), vjust = -0.4, color = "black",size=3) +
  ggtitle("Foodborne Illnesses change By Year") +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "gray96"),
        axis.title.x=element_blank(),
        plot.title = element_text(hjust = 0.5, size=14))

# By Month
outbreak_month <- outbreak %>% 
  group_by(Month) %>%
  summarise(Illness = sum(Illnesses, na.rm=T)) 
outbreak_month$Month <- substr(outbreak_month$Month, 1, 3)
outbreak_month$Month <- factor(outbreak_month$Month, month.abb, ordered=TRUE)

outbreak_month %>% 
  ggplot(aes(x = Month, y = Illness)) +
  geom_bar(stat = "identity", fill = "cadetblue3") +
  geom_text(aes(label = Illness), vjust = -0.4, color = "black",size=3) +
  ggtitle("Foodborne Illnesses change By Month") +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "gray96"),
        axis.title.x=element_blank(),
        plot.title = element_text(hjust = 0.5, size=14))

```


### Time series plot of illnesses caused by top4 species

```{r}
outbreak %>% filter(Species %in% c(
  "Norovirus genogroup I",
  "Salmonella enterica",
  "Norovirus genogroup II",
  "Clostridium perfringens"
)) %>%
  group_by(Year, Species) %>%
  summarise(Illnesses = sum(Illnesses, na.rm=T)) %>% 
  ggplot(aes(x=Year, y=Illnesses, lty=Species, col=Species)) + 
  geom_line()
```

# Model Building


## Preprocessing before model builing 

```{r}
foodCatXform <- function(val) { 
  igCase = TRUE
  if ( ( regexpr("vegetarian",val, ignore.case=igCase)>0 || regexpr("vegan",val, ignore.case=igCase)>0 || regexpr("veggie",val, ignore.case=igCase)>0 || regexpr("salad",val, ignore.case=igCase)>0 || regexpr("meatless",val, ignore.case=igCase)>0 )     && 
       !( regexpr("nonvegan",val, ignore.case=igCase)>0 || regexpr("chicken",val, ignore.case=igCase)>0 || regexpr("someOtherLikeVegeButNotReallyException",val, ignore.case=igCase)>0 ) ) {
    return("Vegetarian")
  } else if ( ( regexpr("chick",val, ignore.case=igCase)>0 || regexpr("chicken",val, ignore.case=igCase)>0 ) && 
       !( regexpr("chickpea",val, ignore.case=igCase)>0 || regexpr("someOtherChickenException",val, ignore.case=igCase)>0 ) ) { 
    return("Chicken") 
  } else if ( ( regexpr("pork",val, ignore.case=igCase)>0 )  ) { 
    return("Pork") 
  } else if ( ( regexpr("beef",val, ignore.case=igCase)>0 || regexpr("steak",val, ignore.case=igCase)>0 || regexpr("meat",val, ignore.case=igCase)>0 ) && 
       !( regexpr("holy cow",val, ignore.case=igCase)>0 || regexpr("beefless",val, ignore.case=igCase)>0 || regexpr("someOtherChickenException",val, ignore.case=igCase)>0 ) ) {
    return("Beef")
  } else if ( ( regexpr("fish",val, ignore.case=igCase)>0 || regexpr("tuna",val, ignore.case=igCase)>0 || regexpr("salmon",val, ignore.case=igCase)>0  ) ) {
    return("Fish")
  } else if ( ( regexpr("eggs",val, ignore.case=igCase)>0 || regexpr("egg",val, ignore.case=igCase)>0 ) && 
       !( regexpr("eggless",val, ignore.case=igCase)>0 ) ) {
    return("Egg")
  }  else if ( ( regexpr("fruit",val, ignore.case=igCase)>0 || regexpr("strawberry",val, ignore.case=igCase)>0 || regexpr("acai",val, ignore.case=igCase)>0 || regexpr("banana",val, ignore.case=igCase)>0 || regexpr("berries",val, ignore.case=igCase)>0 || regexpr("berry",val, ignore.case=igCase)>0 || regexpr("mango",val, ignore.case=igCase)>0 || regexpr("melon",val, ignore.case=igCase)>0)) {
    return("Fruit")
  }  else {
    return("Others")
  }
}

speciesCatXform <- function(val) { 
  igCase = TRUE
  if ( ( regexpr("Norovirus",val, ignore.case=igCase)>0 || regexpr("norovirus",val, ignore.case=igCase)>0 ) ) {
    return("Norovirus")
  } else if ( ( regexpr("Salmonella",val, ignore.case=igCase)>0 ) ){ 
    return("Salmonella") 
  } else if ( ( regexpr("Clostridium perfringens",val, ignore.case=igCase)>0 || regexpr("steak",val, ignore.case=igCase)>0 ) ) {
    return("Clostridium perfringens")
  } else if ( ( regexpr("Staphylococcus",val, ignore.case=igCase)>0)  ) {
    return("Staphylococcus")
  } else if ( ( regexpr("Escherichia coli",val, ignore.case=igCase)>0)  ) {
    return("Escherichia coli")
  } else if ( ( regexpr("Scombroid toxin",val, ignore.case=igCase)>0)  ) {
    return("Scombroid toxin ")
  } else if ( ( regexpr("Bacillus cereus",val, ignore.case=igCase)>0)  ) {
    return("Bacillus cereus")
  } else if ( ( regexpr("Campylobacter jejuni",val, ignore.case=igCase)>0)  ) {
    return("Campylobacter jejuni")
  } else if ( ( regexpr("Ciguatoxin",val, ignore.case=igCase)>0)  ) {
    return("Ciguatoxin")
  }     else {
    return("Others")
  }
}

#https://www.plantmaps.com/koppen-climate-classification-map-united-states.php
#https://en.climate-data.org/

stateCatXform <- function(val) { 
  igCase = TRUE
  if( regexpr("Alabama",val, ignore.case=igCase)>0 ) {
    return("3")
  } else if ( regexpr("Alaska",val, ignore.case=igCase)>0 ) { 
    return("4") 
  } else if ( regexpr("Arizona",val, ignore.case=igCase)>0 ) {
    return("2")
  } else if ( ( regexpr("Arkansas",val, ignore.case=igCase)>0)  ) {
    return("3")
  } else if ( ( regexpr("California",val, ignore.case=igCase)>0)  ) {
    return("3")
  } else if ( ( regexpr("Colorado",val, ignore.case=igCase)>0)  ) {
    return("2")
  } else if ( ( regexpr("Connecticut",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("Delaware",val, ignore.case=igCase)>0)  ) {
    return("3")
  } else if ( ( regexpr("Florida",val, ignore.case=igCase)>0)  ) {
    return("3")
  } else if ( ( regexpr("Georgia",val, ignore.case=igCase)>0)  ) {
    return("3")
  } else if ( ( regexpr("Hawaii",val, ignore.case=igCase)>0)  ) {
    return("1")
  } else if ( ( regexpr("Idaho",val, ignore.case=igCase)>0)  ) {
    return("2")
  } else if ( ( regexpr("Illinois",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("Indiana",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("Iowa",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("Kansas",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("Kentucky",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("Louisiana",val, ignore.case=igCase)>0)  ) {
    return("3")
  } else if ( ( regexpr("Maine",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("Maryland",val, ignore.case=igCase)>0)  ) {
    return("3")
  } else if ( ( regexpr("Massachusetts",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("Michigan",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("Minnesota",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("Mississippi",val, ignore.case=igCase)>0)  ) {
    return("3")
  } else if ( ( regexpr("Missouri",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("Montana",val, ignore.case=igCase)>0)  ) {
    return("2")
  } else if ( ( regexpr("Nebraska",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("Nevada",val, ignore.case=igCase)>0)  ) {
    return("2")
  } else if ( ( regexpr("New Hampshire",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("New Jersey",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("New Mexico",val, ignore.case=igCase)>0)  ) {
    return("2")
  } else if ( ( regexpr("New York",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("North Carolina",val, ignore.case=igCase)>0)  ) {
    return("3")
  } else if ( ( regexpr("North Dakota",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("Ohio",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("Oklahoma",val, ignore.case=igCase)>0)  ) {
    return("3")
  } else if ( ( regexpr("Oregon",val, ignore.case=igCase)>0)  ) {
    return("3")
  } else if ( ( regexpr("Pennsylvania",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("Rhode Island",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("South Carolina",val, ignore.case=igCase)>0)  ) {
    return("3")
  } else if ( ( regexpr("South Dakota",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("Tennessee",val, ignore.case=igCase)>0)  ) {
    return("3")
  } else if ( ( regexpr("Texas",val, ignore.case=igCase)>0)  ) {
    return("3")
  } else if ( ( regexpr("Utah",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("Vermont",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("Virginia",val, ignore.case=igCase)>0)  ) {
    return("3")
  } else if ( ( regexpr("Washington",val, ignore.case=igCase)>0)  ) {
    return("3")
  } else if ( ( regexpr("West Virginia",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("Wisconsin",val, ignore.case=igCase)>0)  ) {
    return("4")
  } else if ( ( regexpr("Wyoming",val, ignore.case=igCase)>0)  ) {
    return("2")
  } else if ( ( regexpr("District of Columbia",val, ignore.case=igCase)>0 || regexpr("DC",val, ignore.case=igCase)>0 ) || regexpr("D.C.",val, ignore.case=igCase)>0 ) {
    return("3")
  } else if ( ( regexpr("American Samoa",val, ignore.case=igCase)>0) || regexpr("Samoa",val, ignore.case=igCase)>0 ) {
    return("1")
  } else if ( ( regexpr("Guam",val, ignore.case=igCase)>0)  ) {
    return("1")
  } else if ( ( regexpr("Mariana",val, ignore.case=igCase)>0)  ) {
    return("1")
  } else if ( ( regexpr("Puerto Rico",val, ignore.case=igCase)>0) || regexpr("PR",val, ignore.case=igCase)>0 ) {
    return("1")
  } else if ( ( regexpr("Virgin Islands",val, ignore.case=igCase)>0) || regexpr("US Virgin Islands",val, ignore.case=igCase)>0 ) {
    return("1")
  }     else {
    return("Others")
  }
}
```

```{r modelpreprocess}
#str(outbreaks)
out = outbreaks[c(2:5, 7)]
str(out)

out$filterFood = sapply(out$Food, FUN = foodCatXform )
out$filterSpecies = sapply(out$Species, FUN = speciesCatXform )
out$filterState = sapply(out$State, FUN = stateCatXform )
#str(out)
out$filterFood = factor(out$filterFood)
out$filterSpecies = factor(out$filterSpecies)
out$filterState = factor(out$filterState)


#koppen climate classification for states 
# https://www.plantmaps.com/koppen-climate-classification-map-united-states.php
# i'll explain this in the paper later 


str(out)
#summary(out$Food)
summary(out$filterState)
summary(out)
#summary(out$filterFood)




```

```{r finalset, eacho=TRUE}
# This is the final data set that includes Species (as the response) and Food, State, and Month (as predictors)

model_data = data.frame(out[,c("Month", "filterFood", "filterSpecies", "filterState")])

head(model_data)

```

## K-Nearest Neighbors

```{r}
outbreaks_predict <- subset(outbreaks, select = c(2, 3, 5, 7))
str(outbreaks_predict)
#xkablesummary(outbreaks_predict)
```

```{r}
loadPkg(psych)
pairs.panels(outbreaks_predict, 
             method = "pearson", # correlation method
             hist.col = "#8855aa", # set histogram color, can use "#22AFBB", "red",
             density = TRUE,  # show density plots
             ellipses = TRUE # show correlation ellipses
             )
unloadPkg(psych)
```

**Train-Test split 3:1**  
In order to perform KNN analysis, we need to separate the X-variables and the y-labels. (Which should be our y-variable?) Before we separate them out, create a vector/array of 1 and 2 to create a train-test split in the ratio of 3:1. (Set a constant seed value so that we can duplicate the results.) So eventually, you will get the training Xs as a dataframe, training y-label (a vector), as well as the test sets together in four groups. Make sure the train-X and train-y are not mixed up in the ordering during the process. Same for test-X and test-y.  

The variable `type` is the only factor level variable we have, and this will be our y-target. All other x-variables should be scaled, and preferrably centered, to facilitate the calculation of distances in KNN in a more meaningful way.  The 3:1 ratio train-test split makes the train set 75% of the dataset.  

```{r}
#str(outbreaks_predict)
#zoutbreaks_predict <- as.data.frame(scale(outbreaks_predict[1:4], center = TRUE, scale = TRUE))
#We also need to create test and train data sets, we will do this slightly differently by using the sample function. The 2 says create 2 data sets essentially, replacement means we can reset the random sampling across each vector and the probability gives sample the weight of the splits, 2/3 for train, 1/3 for test. 
#set.seed(314)
#splitarray <- sample(2, nrow(zpima), replace=TRUE, prob=c(0.75, 0.25))
#
#zpima_Xtrain <- zpima[splitarray==1, 1:7] # dataframe
#zpima_Xtest <- zpima[splitarray==2, 1:7] # dataframe
#zpima_ytrain <- pima[splitarray==1, 8] #  1-D array, use pima, not zpima
#zpima_ytest <- pima[splitarray==2, 8] # 1-D array, use pima, not zpima
```

The train/test sets are prepared, with X and y variables separated as well. We ended up with r length(zpima_ytrain) data point in the train set, and r length(zpima_ytest) data point in the test set.


## Decision Trees

Decision trees are easily understood and interpreted. They are also easily able to use both quantitative and qualitative variables without having to make dummy variables. Here, three tree types are used to movel the data, increasing in complexity for each type. A basic decision tree was used first, then a Random Forest, which makes use of the bootstrap method. Additionally, the constructed trees in the forest are decorrelated by using only a random sample of the predictors and not all of them. The last tree type used was a boosted tree, which has all the benefits of the Random Forest, but with a small variation in the way in which the bagging of the trees occurs. In the boosted forest, the trees are grown sequentially, using information from previously grown trees. This should result in higher levels of accuracy. 

**The Data Used**
Ultimately, there were 12 species in the response; Bacillus cereus, Campylobacter jejuni, Ciguatoxin (from Gambierdiscus toxicus), Clostridium perfringens, Escherichia coli, Norovirus, Salmonella, Scombroid toxin (produced by a variety of bacteria growing within fish), Staphylococcus, and the rest grouped as Others. As for the predictor variables, there were 12 levels for months (Jan-Dec), 4 levels set for State (separated by region, as explained above), and 8 levels for the Food; Beef, Chicken, Egg, Fish, Fruit, Pork, Vegetarian, and Other. 

**Train-Test split 3:1** 
As was done in KNN, the data was split into a 3:1 split for training and testing data. The first 75% of the rows were used for training (14339 observations) and the last 25% was used for testing (4780 observations). However, because decision trees can classify categorical data, all variables were left as factors. 

```{r testtrain, results=FALSE}
n <- nrow(model_data)
n_train <- round(0.8 * n) 
set.seed(1)
train_indices <- sample(1:n, n_train)
dt_train <- model_data[train_indices, ]  
dt_test <- model_data[-train_indices, ]

#smp_size=floor(0.75*nrow(model_data))
#dt_train=sample(seq_len(nrow(model_data)),size=smp_size)

#dt_test=model_data[-dt_train,]
#dt_train=model_data[dt_train,]
```

### Basic Decision Tree

To start the classification process using a decision tree, a basic decision tree was used. No optimization of parameters was initially done, meaning that all parameters were considered at each split, the size of the forest was at default (500 trees), and no splitting criterion as set. This basic decision tree had an overall accuracy of only 41.7%. Additionally, the sensitivity was 0% for all species except Scombroid toxin producing bacteria and those falling into the "Other" category. The specificty was at 100% for all except those falling into the Scomboid toxin producing bacteria, in which it was 97.6% and those falling into the "Others" category at 5.1%. This indicates that this decision tree does not correctly identify the causative agent (Species) except when the causative agent is a Scombroid toxin producer, in which case it identifies it 78.4% of the time correctly. The combination of low sensitivity and high specificity for most Species, but los specificty for a few, indicates that many of the predictions from this decision tree are getting assigned to the same Species. In lookin at the confusion matrix, you can see that almost every prediction is that of the response "Other". 
```{r basicdt, results=TRUE}

# basic decision tree with default parameters
tree.outbreaks = tree(filterSpecies~.,dt_train)
tree.pred = predict(tree.outbreaks,dt_test,type="class")
table(tree.pred,dt_test$filterSpecies) # confusion matrix
#mean(tree.pred==dt_test$filterSpecies) # gives accuracy


cm = confusionMatrix( tree.pred, dt_test$filterSpecies)
print('Overall: ')
cm$overall
print('Class: ')
cm$byClass



```

Overall, this basic decision tree does not work well, as it is predicting that almost each case of food poisoning is caused by the group "Other". As 13811 of the 19119 observations are categorized into the "Other" category, this is indicative that the data is unbalanced, and explains the lack of predictive capability. 

### Random Forest

### Extreme Gradient Boost Tree

```{r XGB, results=TRUE}


```

# References

James, G., Witten, D., Hastie, T., & Tibshirani, R. (2013). An introduction to statistical learning: with applications in R. New York, NY: Springer Science.